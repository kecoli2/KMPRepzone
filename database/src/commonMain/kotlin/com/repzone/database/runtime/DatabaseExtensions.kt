package com.repzone.database.runtime

import app.cash.sqldelight.db.SqlDriver
import app.cash.sqldelight.db.SqlPreparedStatement

// EntityMetadataRegistry - Bu KSP tarafından generate edilecek, şimdilik placeholder
object EntityMetadataRegistry {
    inline fun <reified T : Any> get(): EntityMetadata {
        throw NotImplementedError("This will be generated by KSP")
    }
}

// Main select function
inline fun <reified T : Any> SqlDriver.select(
    block: SelectBuilder<T>.() -> Unit = {}
): SelectBuilder<T> {
    val metadata = EntityMetadataRegistry.get<T>()
    return SelectBuilder<T>(metadata, this).apply(block)
}

// Insert - reified olmayan versiyon
fun SqlDriver.insert(entity: Any): Long {
    val metadata: EntityMetadata = when (entity::class.simpleName) {
        // KSP burayı dolduracak
        else -> throw IllegalArgumentException("Unknown entity type: ${entity::class.simpleName}")
    }
    val values = metadata.extractValues(entity)

    // AutoIncrement kolonları çıkar
    val insertColumns = metadata.columns.filterNot { it.isAutoIncrement }

    val columnNames = insertColumns.joinToString(", ") { it.name }
    val placeholders = insertColumns.joinToString(", ") { "?" }

    val sql = "INSERT INTO ${metadata.tableName} ($columnNames) VALUES ($placeholders)"

    return execute(
        identifier = null,
        sql = sql,
        parameters = insertColumns.size
    ) {
        insertColumns.forEachIndexed { index, col ->
            bindValue(this, index + 1, values[col.name])
        }
    }.value
}

// Update
fun SqlDriver.update(entity: Any): Int {
    val metadata: EntityMetadata = when (entity::class.simpleName) {
        // KSP burayı dolduracak
        else -> throw IllegalArgumentException("Unknown entity type: ${entity::class.simpleName}")
    }
    val values = metadata.extractValues(entity)
    val pk = metadata.primaryKey

    val updateColumns = metadata.columns.filterNot { it.isPrimaryKey }

    val setClause = updateColumns.joinToString(", ") { "${it.name} = ?" }
    val whereClause = "${pk.name} = ?"

    val sql = "UPDATE ${metadata.tableName} SET $setClause WHERE $whereClause"

    return execute(
        identifier = null,
        sql = sql,
        parameters = updateColumns.size + 1
    ) {
        updateColumns.forEachIndexed { index, col ->
            bindValue(this, index + 1, values[col.name])
        }
        bindValue(this, updateColumns.size + 1, values[pk.name])
    }.value.toInt()
}

// Delete entity
fun SqlDriver.delete(entity: Any): Int {
    val metadata: EntityMetadata = when (entity::class.simpleName) {
        // KSP burayı dolduracak
        else -> throw IllegalArgumentException("Unknown entity type: ${entity::class.simpleName}")
    }
    val values = metadata.extractValues(entity)
    val pk = metadata.primaryKey

    val sql = "DELETE FROM ${metadata.tableName} WHERE ${pk.name} = ?"

    return execute(
        identifier = null,
        sql = sql,
        parameters = 1
    ) {
        bindValue(this, 1, values[pk.name])
    }.value.toInt()
}

// Delete with criteria
class DeleteBuilder<T : Any>(
    private val metadata: EntityMetadata,
    private val driver: SqlDriver
) {
    private var whereCondition: Condition = NoCondition

    fun where(block: CriteriaBuilder.() -> Unit) {
        val builder = CriteriaBuilder()
        builder.block()
        whereCondition = builder.build()
    }

    fun execute(): Int {
        val params = mutableListOf<Any?>()

        val whereClause = if (whereCondition != NoCondition) {
            " WHERE ${whereCondition.toSQL(params)}"
        } else {
            error("WHERE clause is required for delete with criteria")
        }

        val sql = "DELETE FROM ${metadata.tableName}$whereClause"

        return driver.execute(
            identifier = null,
            sql = sql,
            parameters = params.size
        ) {
            params.forEachIndexed { index, value ->
                bindValue(this, index + 1, value)
            }
        }.value.toInt()
    }
}

inline fun <reified T : Any> SqlDriver.delete(
    block: DeleteBuilder<T>.() -> Unit
): Int {
    val metadata = EntityMetadataRegistry.get<T>()
    val builder = DeleteBuilder<T>(metadata, this)
    builder.block()
    return builder.execute()
}

// Helper function for binding values
internal fun bindValue(statement: app.cash.sqldelight.db.SqlPreparedStatement, index: Int, value: Any?) {
    when (value) {
        null -> statement.bindBytes(index, null)
        is String -> statement.bindString(index, value)
        is Long -> statement.bindLong(index, value)
        is Int -> statement.bindLong(index, value.toLong())
        is Boolean -> statement.bindLong(index, if (value) 1L else 0L)
        is Double -> statement.bindDouble(index, value)
        is Float -> statement.bindDouble(index, value.toDouble())
        is ByteArray -> statement.bindBytes(index, value)
        else -> statement.bindString(index, value.toString())
    }
}